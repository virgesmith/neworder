
#include "ConcurrentLogger.h"
#include <iostream>
#include <iomanip>
#include <ctime>
#include <unistd.h>

namespace {

const char* timeStr(const std::chrono::system_clock::time_point t)
{
	time_t tt = std::chrono::system_clock::to_time_t(t);
	struct tm* ttt;
	ttt = localtime(&tt);
	static char buffer[32];
	strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", ttt);
	return buffer;
}

const char* hostname()
{
	static char buffer[64];
	gethostname(buffer, sizeof(buffer));
	return buffer;
}

}

ConcurrentLogger::ConcurrentLogger() : 
	m_finished(false),
  m_startTime(std::chrono::system_clock::now()),
	m_filter("DIWEAF")
{
  push_impl(LogInfo((LogLevel)'L',format("%% %% logging started", timeStr(m_startTime), hostname())));	
	m_dispatcher = std::thread([this]() {
		while (!m_finished) 
		{
			pop();
		}		
	});
}

ConcurrentLogger::~ConcurrentLogger() 
{
  {
	  std::lock_guard<std::mutex> lock(m_mutex);
    m_finished = true;
  }
  // push final message 
	push_impl(LogInfo((LogLevel)'L', "logging stopped"));
	// wait for thread to end (which might be blocked waiting for another message)
	m_dispatcher.join(); 
	
  // then pop any remaining
	while(!m_queue.empty())
  {
    pop();
  }
}

void ConcurrentLogger::setFilter(const std::string& filter)
{
	push_impl(LogInfo((LogLevel)'L',format("Filter=%%", filter)));
	m_filter = filter;
}
 
void ConcurrentLogger::push(LogInfo&& item)
{
	if (m_filter.find_first_of((char)item.level) != std::string::npos)
	{
		push_impl(std::forward<LogInfo>(item));
	}
}

void ConcurrentLogger::push_impl(LogInfo&& item)
{
	std::unique_lock<std::mutex> lock(m_mutex);
  m_cond.wait(lock, [this]() { return m_queue.size() < 100; });
  item.timestamp = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - m_startTime);
	m_queue.push(item);
	lock.unlock();
	m_cond.notify_all();
}

void ConcurrentLogger::pop()
{
  std::unique_lock<std::mutex> lock(m_mutex);
  // Thread stuck here...
  m_cond.wait(lock, [this]() { return !m_queue.empty(); });
  
  const LogInfo& item = m_queue.front();
	std::cout << std::setfill('0') << std::setw(5) << item.timestamp.count() / 1000000 
	  << "." << std::setfill('0') << std::setw(6) << item.timestamp.count() % 1000000 
		<< " " << (char)item.level 
		<< ": " << item.message << "\n";
  m_queue.pop();	
  lock.unlock();
  m_cond.notify_all();
}

